% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/indexByRow.R
\name{indexByRow}
\alias{indexByRow}
\title{Translates matrix indices by rows into indices by columns}
\usage{
indexByRow(dim, idxs = NULL, ...)
}
\arguments{
\item{dim}{A \code{\link[base]{numeric}} \code{\link[base]{vector}} of
length two specifying the length of the "template" matrix.}

\item{idxs}{A \code{\link[base]{vector}} indicating subset of elements to
operate over. If \code{\link[base]{NULL}}, no subsetting is done.}

\item{...}{Not used.}
}
\value{
Returns an \code{\link[base]{integer}} \code{\link[base]{vector}} of
indices.
}
\description{
Translates matrix indices by rows into indices by columns.
}
\section{Known limitations}{

The current implementation does not support long-vector indices,
because both input and output indices are of type integers.
This means that the indices in argument \code{idxs} can only be in
range [1,2^31-1]. Using a greater value will be coerced to
\code{NA_integer_}.  Moreover, returned indices can only be in the
same range [1,2^31-1].
}

\examples{
dim <- c(5, 4)
X <- matrix(NA_integer_, nrow = dim[1], ncol = dim[2])
Y <- t(X)
idxs <- seq_along(X)

# Assign by columns
X[idxs] <- idxs
print(X)

# Assign by rows
Y[indexByRow(dim(Y), idxs)] <- idxs
print(Y)

stopifnot(X == t(Y))
}
\author{
Henrik Bengtsson
}
\keyword{iteration}
\keyword{logic}
